# Quick Reference: Linux Compatibility\n\n## Platform Detection Matrix\n\n```csharp\n// Use these patterns throughout the codebase\n\nif (OperatingSystem.IsWindows())\n{\n    // Windows-specific code\n}\nelse if (OperatingSystem.IsLinux())\n{\n    // Linux-specific code\n}\nelse\n{\n    // Fallback for unknown platforms\n}\n```\n\n## Conditional Compilation\n\n```csharp\n// For code that only compiles on Windows\n#if NET8_0_WINDOWS\nusing NAudio.CoreAudioApi;\n#endif\n\npublic class MyWindowsCode\n{\n#if NET8_0_WINDOWS\n    private MMDeviceEnumerator _enumerator;\n    \n    public void WindowsOnlyMethod() { }\n#endif\n}\n```\n\n## File Path Handling\n\n```csharp\n// CORRECT: Cross-platform\nvar appData = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);\nvar configPath = Path.Combine(appData, \"MyApp\", \"config.json\");\n\n// WRONG: Windows-specific\nvar configPath = @\"C:\\Users\\User\\AppData\\Roaming\\MyApp\\config.json\";\n\n// WRONG: Linux-specific\nvar configPath = \"/home/user/.config/myapp/config.json\";\n```\n\n## External Process Execution\n\n```csharp\n// CORRECT: Cross-platform safe\nvar psi = new ProcessStartInfo\n{\n    FileName = \"ffmpeg\",\n    UseShellExecute = false,\n    CreateNoWindow = true,\n    RedirectStandardInput = true,\n    RedirectStandardOutput = true\n};\n\npsi.ArgumentList.Add(\"-i\");\npsi.ArgumentList.Add(filePath);\npsi.ArgumentList.Add(\"-f\");\npsi.ArgumentList.Add(\"mp3\");\npsi.ArgumentList.Add(\"pipe:1\");\n\nvar process = Process.Start(psi);\n\n// WRONG: Shell-dependent\nvar psi = new ProcessStartInfo\n{\n    FileName = \"cmd.exe\",\n    Arguments = $\"/c ffmpeg -i \\\"{filePath}\\\" -f mp3 pipe:1\",\n    UseShellExecute = true\n};\n```\n\n## JSON Serialization\n\n```csharp\n// CORRECT: Cross-platform\nusing System.Text.Json;\n\nvar options = new JsonSerializerOptions { WriteIndented = true };\nvar json = JsonSerializer.Serialize(data, options);\nvar deserialized = JsonSerializer.Deserialize<MyType>(json, options);\n\n// Uses UTF-8 by default (cross-platform)\n```\n\n## Number Parsing\n\n```csharp\n// CORRECT: Locale-independent\nusing System.Globalization;\n\nif (int.TryParse(input, NumberStyles.Integer, \n    CultureInfo.InvariantCulture, out var result))\n{\n    // Parse successful\n}\n\n// WRONG: Locale-dependent\nif (int.TryParse(input, out var result))\n{\n    // May fail on non-English locales\n}\n```\n\n## String Encoding\n\n```csharp\n// CORRECT: Explicit encoding\nvar bytes = Encoding.UTF8.GetBytes(text);\nvar text = Encoding.UTF8.GetString(bytes);\n\n// Protocol headers (ASCII always safe)\nvar headerBytes = Encoding.ASCII.GetBytes(header);\n\n// WRONG: Platform-dependent default\nvar bytes = Encoding.Default.GetBytes(text); // DON'T\n```\n\n## Factory Pattern for Platform Code\n\n```csharp\n// Define interface\npublic interface IAudioOutput\n{\n    void Play();\n    void Stop();\n}\n\n// Implement for each platform\npublic class WaveOutAudioOutput : IAudioOutput { } // Windows\npublic class PaplayAudioOutput : IAudioOutput { }  // Linux\n\n// Factory creates appropriate implementation\npublic static class AudioOutputFactory\n{\n    public static IAudioOutput Create()\n    {\n        if (OperatingSystem.IsWindows())\n            return new WaveOutAudioOutput();\n        \n        if (OperatingSystem.IsLinux())\n            return new PaplayAudioOutput();\n        \n        throw new PlatformNotSupportedException();\n    }\n}\n\n// Usage: transparently cross-platform\nvar output = AudioOutputFactory.Create();\noutput.Play();\n```\n\n## Audio Input/Output Pattern\n\n```csharp\n// Windows: NAudio\nvar waveIn = new WaveInEvent { DeviceNumber = deviceId };\nvar waveOut = new WaveOutEvent { DeviceNumber = deviceId };\n\n// Linux: FFmpeg/ALSA\nvar ffmpeg = new ProcessStartInfo { FileName = \"ffmpeg\", ... };\nvar process = Process.Start(ffmpeg);\nvar stream = process.StandardOutput.BaseStream; // Read audio\n```\n\n## Threading (Cross-Platform)\n\n```csharp\n// CORRECT: Works on all platforms\nawait Task.Run(() => DoWork());\nawait SomeAsyncMethod();\n\nvar thread = new Thread(DoWork) { IsBackground = true };\nthread.Start();\n\nusing var cts = new CancellationTokenSource();\nawait ProcessAsync(cts.Token);\n\n// WRONG: Windows-specific\nSynchronizationContext.Current.Post(...);\nApplication.Current.Dispatcher.Invoke(...); // WPF-specific\n```\n\n## Networking (Cross-Platform)\n\n```csharp\n// CORRECT: Works on all platforms\nvar client = new TcpClient();\nawait client.ConnectAsync(host, port);\nvar stream = client.GetStream();\n\nvar ssl = new SslStream(stream, false);\nawait ssl.AuthenticateAsClientAsync(host);\n\n// WRONG: Platform-specific\nvar socket = new Socket(...); // Lower-level, more complex\n```\n\n## Async/Await (Cross-Platform)\n\n```csharp\n// CORRECT: Works on all platforms\npublic async Task ProcessAudioAsync(Stream input)\n{\n    var buffer = new byte[4096];\n    int bytesRead = await input.ReadAsync(buffer, 0, buffer.Length);\n    // ...\n}\n\n// Can await on any platform\nawait myAudioService.PlayAsync(file);\n\n// Cancellation token for timeout safety\nusing var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));\nawait ProcessAsync(cts.Token);\n```\n\n## Disposing Resources\n\n```csharp\n// CORRECT: Proper cleanup on all platforms\nusing (var process = Process.Start(psi))\n{\n    using (var stdout = process.StandardOutput.BaseStream)\n    {\n        // Process stdout\n    }\n} // Automatic cleanup\n\n// Or with IDisposable\npublic sealed class AudioService : IDisposable\n{\n    private Process? _process;\n    \n    public void Dispose()\n    {\n        if (_process != null)\n        {\n            _process.Dispose();\n            _process = null;\n        }\n    }\n}\n```\n\n## Logging (Cross-Platform)\n\n```csharp\n// CORRECT: Cross-platform logging\nusing Microsoft.Extensions.Logging;\nusing Serilog;\n\nvar logger = LoggerFactory.Create(builder => \n    builder.AddSerilog());\n\nlogger.LogInformation(\"Application started\");\nlogger.LogWarning(\"Audio device not found\");\nlogger.LogError(ex, \"Failed to start stream\");\n\n// Log to file (cross-platform)\nvar logPath = Path.Combine(\n    Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),\n    \"MyApp\", \"logs\", $\"app-{DateTime.Now:yyyy-MM-dd}.log\"\n);\n```\n\n## Checking Linux-Specific Features\n\n```csharp\n// Safe to check for Linux devices\nif (OperatingSystem.IsLinux() && File.Exists(\"/dev/snd/pcmC0D0c\"))\n{\n    // ALSA device found\n}\n\n// Safe to check for PulseAudio\nif (OperatingSystem.IsLinux())\n{\n    var pactl = RunProcess(\"pactl\", new[] { \"list\", \"sources\" });\n    if (!string.IsNullOrEmpty(pactl))\n    {\n        // PulseAudio available\n    }\n}\n\n// File.Exists() returns false on Windows for Linux paths\nif (File.Exists(\"/etc/fstab\")) // False on Windows, OK to use\n{\n    // Linux system\n}\n```\n\n## Environment Variables (Cross-Platform)\n\n```csharp\n// CORRECT: Works on all platforms\nvar apiKey = Environment.GetEnvironmentVariable(\"API_KEY\");\nvar debugMode = Environment.GetEnvironmentVariable(\"DEBUG_MODE\");\n\n// NOT: Platform-specific env vars\nvar appData = Environment.GetEnvironmentVariable(\"APPDATA\"); // Windows only\nvar home = Environment.GetEnvironmentVariable(\"HOME\"); // Linux/macOS only\n\n// USE: Standard .NET APIs instead\nvar appData = Environment.GetFolderPath(\n    Environment.SpecialFolder.ApplicationData); // Cross-platform\n```\n\n## Debugging Platform Issues\n\n```csharp\n// Log what platform we're on\nvar platform = OperatingSystem.IsWindows() ? \"Windows\" :\n               OperatingSystem.IsLinux() ? \"Linux\" :\n               OperatingSystem.IsMacOS() ? \"macOS\" :\n               \"Unknown\";\nlogger.LogInformation($\"Running on: {platform}\");\n\n// Check for specific features\nlogger.LogInformation($\"FFmpeg available: {HasCommand(\\\"ffmpeg\\\")}\");\nlogger.LogInformation($\"PulseAudio available: {HasCommand(\\\"pactl\\\")}\");\n\nprivate static bool HasCommand(string command)\n{\n    try\n    {\n        var psi = new ProcessStartInfo\n        {\n            FileName = command,\n            Arguments = \"--version\",\n            UseShellExecute = false,\n            RedirectStandardOutput = true\n        };\n        var process = Process.Start(psi);\n        return process?.WaitForExit(2000) == true && process.ExitCode == 0;\n    }\n    catch\n    {\n        return false;\n    }\n}\n```\n\n---\n\n## Checklist for New Code\n\n- [ ] No hardcoded C:\\ or /home/ paths\n- [ ] Uses Path.Combine() for all paths\n- [ ] Uses Environment.GetFolderPath() for special folders\n- [ ] Platform selection via OperatingSystem.Is*() or #if\n- [ ] External processes use ArgumentList (not string concatenation)\n- [ ] Encoding explicitly specified (UTF8 or ASCII)\n- [ ] Number parsing uses CultureInfo.InvariantCulture\n- [ ] JSON uses System.Text.Json\n- [ ] Threading uses async/await or Task\n- [ ] Networking uses System.Net.Sockets\n- [ ] UI uses Avalonia or platform-agnostic code\n- [ ] No Windows-only NuGet packages (unless guarded)\n- [ ] Resources properly disposed\n- [ ] Tests run on both Windows and Linux\n\n---\n\n**Build Command (All Platforms):**\n```bash\ndotnet build -c Release\n```\n\n**Run Command (All Platforms):**\n```bash\ndotnet run --configuration Release\n```\n\n**Platform-Specific RID:**\n```bash\ndotnet publish -c Release -r linux-x64    # Linux\ndotnet publish -c Release -r win-x64      # Windows\ndotnet publish -c Release -r osx-x64      # macOS\n```\n"